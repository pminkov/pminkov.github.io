<!DOCTYPE html>
<html lang="en">
<head>
        <meta charset="utf-8" />
        <title>Implementing a fast multi-threaded counter.</title>
        <link rel="stylesheet" href="http://pminkov.github.io/blog/theme/css/main.css" />
        <link href="http://pminkov.github.io/blog/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Petko's Coding Blog Atom Feed" />

        <!--[if IE]>
            <script src="https://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="http://pminkov.github.io/blog/">Petko's Coding Blog </a></h1>
                <nav><ul>
                    <li><a href="http://pminkov.github.io/blog/category/cloud.html">Cloud</a></li>
                    <li><a href="http://pminkov.github.io/blog/category/django.html">Django</a></li>
                    <li class="active"><a href="http://pminkov.github.io/blog/category/linux.html">Linux</a></li>
                    <li><a href="http://pminkov.github.io/blog/category/machine-learning.html">Machine Learning</a></li>
                    <li><a href="http://pminkov.github.io/blog/category/misc.html">Misc</a></li>
                    <li><a href="http://pminkov.github.io/blog/category/python.html">Python</a></li>
                </ul></nav>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="http://pminkov.github.io/blog/implementing-a-fast-multi-threaded-counter.html" rel="bookmark"
           title="Permalink to Implementing a fast multi-threaded counter.">Implementing a fast multi-threaded counter.</a></h1>
    </header>

    <div class="entry-content">
<div class="post-info">
        <div class="published" title="2016-11-23T11:02:00-08:00">
                Published: Wed 23 November 2016
in <a href="http://pminkov.github.io/blog/category/linux.html">Linux</a>
        </div>
<p>Tags: <a href="http://pminkov.github.io/blog/tag/concurrency.html">Concurrency</a> <a href="http://pminkov.github.io/blog/tag/linux.html">Linux</a> </p>
</div><!-- /.post-info -->    </div>
    <div>
      <p>Today I'll write a bit about implementing a simple thread safe counter and improving its speed.</p>
<p>Implementing a basic mutli-threaded counter is a fairly easy task. Using pthreads, you just need to wrap the counter increment in a lock.</p>
<p>The code (<a href="https://github.com/pminkov/wip/tree/master/mt-counters">github link</a>) looks like this:</p>
<p>```</p>
<h1 id="include-mythreadsh">include "mythreads.h"</h1>
<p>struct counter_t {
  int value;
  pthread_mutex_t lock;
};</p>
<p>static struct counter_t counter;</p>
<p>void init(struct counter_t *c) {
  c-&gt;value = 0;
  pthread_mutex_init(&amp;c-&gt;lock, NULL);
}</p>
<p>void increment_by(struct counter_t *c, int by) {
  Pthread_mutex_lock(&amp;c-&gt;lock);
  c-&gt;value += by;
  Pthread_mutex_unlock(&amp;c-&gt;lock);
}</p>
<p>void increment(struct counter_t *c) {
  increment_by(c, 1);
}</p>
<p>int get(struct counter_t *c) {
  Pthread_mutex_lock(&amp;c-&gt;lock);
  int rc = c-&gt;value;
  Pthread_mutex_unlock(&amp;c-&gt;lock);
  return rc;
}
```</p>
<p>Nothing complicated. Let's say that we want to increment this counter 1,000,000 times. And let's do this with an increasing amount of threads, each thread incrementing the counter 1,000,000 times. I get the following timings for this exercise.</p>
<p><code>1 thread:  0.064s real time.
2 threads: 9.930s
4 threads: 23.971s</code></p>
<p>This counter is really slow. Also, it doesn't scale well, since at the moment more than one thread starts to use it, it becomes so much slower. Why is this? Well, it's a bit difficult to tell without knowing how mutexes are implemented, but since we're using a single mutex that has to switch between two threads, it looks like there's a lot of overhead in this. The core operation - the increment, is also not parallel, since it can be done by only one thread at a time. But judging from the single threaded timing, this operation by itself is not the bottleneck here. So the synchronization must be.</p>
<p>How can we improve this? We can use what's called a sloppy counter. The sloppy counter is also fairly easy to understand. Each thread has its own counter and when that counter becomes bigger than a certain value, its current value is transferred into a global counter. Here's how the code for that looks like:</p>
<p>```</p>
<h1 id="include">include <string.h></h1>
<h1 id="include_1">include <stdlib.h></h1>
<h1 id="define-mina-b-a-b-a-b">define min(a, b) ((a) &lt; (b) ? (a) : (b))</h1>
<p>const uint64_t SLOTS_COUNT = 101;</p>
<p>struct sloppy_counter_t {
  int value;</p>
<p>struct counter_t gcounter;</p>
<p>// A hash table for per-thread counters. Since we're unlikely to run too many threads at the same time,
  // chances for collision are low. If that's not the case, we can always use a per-counter mutex.
  int lcounters[SLOTS_COUNT];
};</p>
<p>static struct sloppy_counter_t sloppy_counter;</p>
<p>void sloppy_init(struct sloppy_counter_t *c) {
  for (int i = 0; i &lt; SLOTS_COUNT; i++) {
    c-&gt;lcounters[i] = 0;
  }</p>
<p>init(&amp;c-&gt;gcounter);
}</p>
<p>int slot_id(pthread_t thread_id) {
  uint64_t ptid = 0;
  memcpy(&amp;ptid, &amp;thread_id, min(sizeof(thread_id), sizeof(ptid)));</p>
<p>int sid = ptid % SLOTS_COUNT;
  return sid;
}</p>
<p>void sloppy_increment(struct sloppy_counter_t *c, pthread_t thread_id) {
  int sid = slot_id(thread_id);</p>
<p>c-&gt;lcounters[sid]++;
  if (c-&gt;lcounters[sid] &gt; 128) {
    increment_by(&amp;c-&gt;gcounter, c-&gt;lcounters[sid]);
    c-&gt;lcounters[sid] = 0;
  }
}</p>
<p>void sloppy_flush(struct sloppy_counter_t *c, pthread_t thread_id) {
  int sid = slot_id(thread_id);
  if (c-&gt;lcounters[sid] &gt; 0) {
    increment_by(&amp;c-&gt;gcounter, c-&gt;lcounters[sid]);
  }
}</p>
<p>int sloppy_get(struct sloppy_counter_t *counter) {
  return get(&amp;counter-&gt;gcounter);
}
```</p>
<p>Now let's time this counter.</p>
<p><code>1 thread:  0.026s
2 threads: 0.050s
4 threads: 0.164s</code></p>
<p>Much better! This counter, just like the first one, is thread safe. It's not as accurate, but the inaccuracy is small (at most 128 * number of threads) and we can use the flush function if we want accurate counts.</p>
    </div><!-- /.entry-content -->
    <div class="comments">
      <div id="disqus_thread"></div>
      <script type="text/javascript">
        var disqus_shortname = 'pminkov-blog';
        var disqus_identifier = 'implementing-a-fast-multi-threaded-counter.html';
        var disqus_url = 'http://pminkov.github.io/blog/implementing-a-fast-multi-threaded-counter.html';
        (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//pminkov-blog.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
      </script>
      <noscript>Please enable JavaScript to view the comments.</noscript>
    </div>

  </article>
</section>
        <section id="extras" class="body">
                <div class="social">
                        <h2>social</h2>
                        <ul>
                            <li><a href="http://pminkov.github.io/blog/feeds/all.atom.xml" type="application/atom+xml" rel="alternate">atom feed</a></li>

                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <!--
        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                  Blah blha blah
                </address>
        </footer>
        -->
        <!-- /#contentinfo -->

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-243631-7', 'auto');
  ga('send', 'pageview');

</script>
<script type="text/javascript">
    var disqus_shortname = 'pminkov-blog';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = 'https://' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
</body>
</html>