<!DOCTYPE html>
<html lang="en">
<head>
        <meta charset="utf-8" />
        <title>Implementing a fast multi-threaded counter.</title>
        <link rel="stylesheet" href="/theme/css/main.css" />

        <!--[if IE]>
            <script src="https://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="/">Petko's Coding Blog </a></h1>
                <nav><ul>
                    <li><a href="/category/aws.html">AWS</a></li>
                    <li class="active"><a href="/category/concurrency.html">Concurrency</a></li>
                    <li><a href="/category/django.html">Django</a></li>
                    <li><a href="/category/linux.html">Linux</a></li>
                    <li><a href="/category/python.html">Python</a></li>
                </ul></nav>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="/implementing-a-fast-multi-threaded-counter.html" rel="bookmark"
           title="Permalink to Implementing a fast multi-threaded counter.">Implementing a fast multi-threaded counter.</a></h1>
    </header>

    <div class="entry-content">
<div class="post-info">
        <abbr class="published" title="2016-11-23T11:02:00-08:00">
                Published: Wed 23 November 2016
in <a href="/category/concurrency.html">Concurrency</a>
        </abbr>
<p>Tags: <a href="/tag/concurrency.html">Concurrency</a> <a href="/tag/linux.html">Linux</a> </p>
</div><!-- /.post-info -->    </div>
    <div>
      <p>Today I'll write a bit about implementing a simple thread safe counter and improving its speed.</p>
<p>Implementing a basic mutli-threaded counter is a fairly easy task. Using pthreads, you just need to wrap the counter increment in a lock.</p>
<p>The code (<a href="https://github.com/pminkov/wip/tree/master/mt-counters">github link</a>) looks like this:</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;mythreads.h&quot;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">counter_t</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
  <span class="n">pthread_mutex_t</span> <span class="n">lock</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">counter_t</span> <span class="n">counter</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">init</span><span class="p">(</span><span class="k">struct</span> <span class="n">counter_t</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">c</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">increment_by</span><span class="p">(</span><span class="k">struct</span> <span class="n">counter_t</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">by</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
  <span class="n">c</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">+=</span> <span class="n">by</span><span class="p">;</span>
  <span class="n">Pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">increment</span><span class="p">(</span><span class="k">struct</span> <span class="n">counter_t</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">increment_by</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">get</span><span class="p">(</span><span class="k">struct</span> <span class="n">counter_t</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
  <span class="n">Pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Nothing complicated. Let's say that we want to increment this counter 1,000,000 times. And let's do this with an increasing amount of threads, each thread incrementing the counter 1,000,000 times. I get the following timings for this exercise.</p>
<div class="highlight"><pre><span></span>1 thread:  0.064s real time.
2 threads: 9.930s
4 threads: 23.971s
</pre></div>


<p>This counter is really slow. Also, it doesn't scale well, since at the moment more than one thread starts to use it, it becomes so much slower. Why is this? Well, it's a bit difficult to tell without knowing how mutexes are implemented, but since we're using a single mutex that has to switch between two threads, it looks like there's a lot of overhead in this. The core operation - the increment, is also not parallel, since it can be done by only one thread at a time. But judging from the single threaded timing, this operation by itself is not the bottleneck here. So the synchronization must be.</p>
<p>How can we improve this? We can use what's called a sloppy counter. The sloppy counter is also fairly easy to understand. Each thread has its own counter and when that counter becomes bigger than a certain value, its current value is transferred into a global counter. Here's how the code for that looks like:</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>

<span class="cp">#define min(a, b) ((a) &lt; (b) ? (a) : (b))</span>

<span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">SLOTS_COUNT</span> <span class="o">=</span> <span class="mi">101</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">sloppy_counter_t</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>

  <span class="k">struct</span> <span class="n">counter_t</span> <span class="n">gcounter</span><span class="p">;</span>

  <span class="c1">// A hash table for per-thread counters. Since we&#39;re unlikely to run too many threads at the same time,</span>
  <span class="c1">// chances for collision are low. If that&#39;s not the case, we can always use a per-counter mutex.</span>
  <span class="kt">int</span> <span class="n">lcounters</span><span class="p">[</span><span class="n">SLOTS_COUNT</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">sloppy_counter_t</span> <span class="n">sloppy_counter</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">sloppy_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">sloppy_counter_t</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SLOTS_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">c</span><span class="o">-&gt;</span><span class="n">lcounters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">gcounter</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">slot_id</span><span class="p">(</span><span class="n">pthread_t</span> <span class="n">thread_id</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">uint64_t</span> <span class="n">ptid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">thread_id</span><span class="p">,</span> <span class="n">min</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">thread_id</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ptid</span><span class="p">)));</span>

  <span class="kt">int</span> <span class="n">sid</span> <span class="o">=</span> <span class="n">ptid</span> <span class="o">%</span> <span class="n">SLOTS_COUNT</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">sid</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sloppy_increment</span><span class="p">(</span><span class="k">struct</span> <span class="n">sloppy_counter_t</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">pthread_t</span> <span class="n">thread_id</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">sid</span> <span class="o">=</span> <span class="n">slot_id</span><span class="p">(</span><span class="n">thread_id</span><span class="p">);</span>

  <span class="n">c</span><span class="o">-&gt;</span><span class="n">lcounters</span><span class="p">[</span><span class="n">sid</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lcounters</span><span class="p">[</span><span class="n">sid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">128</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">increment_by</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">gcounter</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lcounters</span><span class="p">[</span><span class="n">sid</span><span class="p">]);</span>
    <span class="n">c</span><span class="o">-&gt;</span><span class="n">lcounters</span><span class="p">[</span><span class="n">sid</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sloppy_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">sloppy_counter_t</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">pthread_t</span> <span class="n">thread_id</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">sid</span> <span class="o">=</span> <span class="n">slot_id</span><span class="p">(</span><span class="n">thread_id</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lcounters</span><span class="p">[</span><span class="n">sid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">increment_by</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">gcounter</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lcounters</span><span class="p">[</span><span class="n">sid</span><span class="p">]);</span>
  <span class="p">}</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">sloppy_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">sloppy_counter_t</span> <span class="o">*</span><span class="n">counter</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">gcounter</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>Now let's time this counter.</p>
<div class="highlight"><pre><span></span>1 thread:  0.026s
2 threads: 0.050s
4 threads: 0.164s
</pre></div>


<p>Much better! This counter, just like the first one, is thread safe. It's not as accurate, but the inaccuracy is small (at most 128 * number of threads) and we can use the flush function if we want accurate counts.</p>
    </div><!-- /.entry-content -->

  </article>
</section>
        <section id="extras" class="body">
        </section><!-- /#extras -->

        <!--
        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                  Blah blha blah
                </address>
        </footer>
        -->
        <!-- /#contentinfo -->

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-243631-7', 'auto');
  ga('send', 'pageview');

</script>
</body>
</html>